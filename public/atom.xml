<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一点心怡 | 前端娃]]></title>
  <subtitle><![CDATA[精于心, 简于形, 说前端, 一种新的写作方式]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zanjs.com/"/>
  <updated>2015-12-27T08:47:51.000Z</updated>
  <id>http://zanjs.com/</id>
  
  <author>
    <name><![CDATA[Julaud]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[用 Elixir 的一周]]></title>
    <link href="http://zanjs.com/2015/12/27/%E7%94%A8-Elixir-%E7%9A%84%E4%B8%80%E5%91%A8/"/>
    <id>http://zanjs.com/2015/12/27/用-Elixir-的一周/</id>
    <published>2015-12-27T08:38:08.000Z</published>
    <updated>2015-12-27T08:47:51.000Z</updated>
    <content type="html"><![CDATA[<p>大约一周前我开始学习Elixir. 关于这个我也只是有些模糊的印象但还没有仔细去看。</p> <p>但在Dave Thomas 出版了 <a href="https://pragprog.com/book/elixir/programming-elixir" target="_blank" rel="external">Programming Elixir</a>之后一切都发生了改变.<br> Dave Thomas 帮我修订过Erlang这本书并且是Ruby的倡导者, 只要Dave对什么产生了兴趣那绝不是空穴来风.</p> <p> Dave 对Elixir很感兴趣, 在他的书里这样写道:</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> I came across Ruby <span class="operator">in</span> <span class="number">1998</span> because I was <span class="operator">an</span> avid </span><br><span class="line">reader <span class="operator">of</span> comp.lang.misc (ask your parents). I </span><br><span class="line">downloaded <span class="keyword">it</span>, compiled <span class="keyword">it</span>, <span class="operator">and</span> fell <span class="operator">in</span> love. </span><br><span class="line">As <span class="operator">with</span> <span class="keyword">any</span> <span class="built_in">time</span> you fall <span class="operator">in</span> love,</span><br><span class="line"><span class="keyword">it</span>’s difficult <span class="built_in">to</span> explain why. </span><br><span class="line">It just worked <span class="operator">the</span> way I work, </span><br><span class="line"><span class="operator">and</span> <span class="keyword">it</span> had enough depth <span class="built_in">to</span> keep me interested.</span><br><span class="line"></span><br><span class="line">Fast forward <span class="number">15</span> years. All that <span class="built_in">time</span> I’d been </span><br><span class="line">looking <span class="keyword">for</span> something <span class="built_in">new</span> that gave me <span class="operator">the</span> same feeling.</span><br><span class="line"></span><br><span class="line">I came across Elixir <span class="operator">a</span> <span class="keyword">while</span> back, but <span class="keyword">for</span> some </span><br><span class="line">reason never got stuck <span class="operator">in</span>. But <span class="operator">a</span> few months ago I </span><br><span class="line">was chatting <span class="operator">with</span> Corey Haines. I was</span><br><span class="line">bemoaning <span class="operator">the</span> fact that I wanted <span class="built_in">to</span> find <span class="operator">a</span> </span><br><span class="line">way <span class="built_in">to</span> show people functional programming concepts </span><br><span class="line"><span class="keyword">without</span> <span class="operator">the</span> kind <span class="operator">of</span> academic trappings those books </span><br><span class="line">seem <span class="built_in">to</span> attract. He told me <span class="built_in">to</span> look again <span class="keyword">at</span> Elixir. I</span><br><span class="line">did, <span class="operator">and</span> I felt <span class="operator">the</span> same way I felt when I <span class="keyword">first</span> saw Ruby.</span><br></pre></td></tr></table></figure> <p> 我能体会.纯粹的感官体验. 就像我知道一件事是对的但还不知道原因，<br> 几周甚至几年后这个问题总能回答出来. Malcolm Gladwell在Blink:<br> The Power of Thinking Without Thinking一书中曾探讨过这个问题.<br> 某些领域专家们总能凭直觉判断事情的正确与否，但却给不出具体原因.</p> <p>但我发现Dave 的描述后，我很想知道为什么他会这样.</p> <p>无独有偶, Simon St. Laurent也出了本Elixir的书.<br>Simon的 Introducing Erlang… 一书表现不俗，我和他还通过邮件沟通过几次，还有有些熟悉的.<br>从Pragmatic Press 和O’Reilly 出版社都在争着出版Elixir可见一斑。关于Erlang VM, 我确实一窍不通。</p> <p>我给Dave和Simon 发了封邮件，之后他们借给我了样书，现在可以开始阅读了 … 谢了 …</p> <h3 id="上周我下载了elixir_开始学习…">上周我下载了elixir 开始学习…</h3><p>没多久我觉得就上手了. 确实好东西. 有趣的是Erlang和Elixir 实际上是同源的.<br>事实上也确实这样，他们都会被EVM (Erlang Virtual Machine)编译 -<br>大家管这个EVM 叫 “Beam” VM 但为了和JVM区别就管他叫EVM 吧.</p> <p>Erlang和Elixir为啥有相同的“语意”? 这得从底层谈起.<br>垃圾回收, 独立并发机制, 错误处理和代码装载机制都是一样的.<br> 还有: 他们都运行在相同的VM里. 这也是Scala 和 Akka区别于 Erlang的原因.<br>Scala和Akka是运行在JVM 上的, 垃圾回收和代码装载机制从本质上就不同.</p> <p>Elixir最明显的特点就是语法的表示，和Ruby很像. 简单易懂，还有很多外部资源。</p> <p>Erlang’s 的语法源自 Prolog 还受到smalltalk, CSP 和功能性编程语言的影响.<br> Elixir 受到Erlang 和Ruby的影响. 类型匹配, 功能优先级错误处理机制都是从Erlang来的.sigils,<br> 语法简写从Ruby 来。 当然也有自己的创新, |&gt; 管道操作, Prologs DCGs 和Haskell monads<br> (简化了一些类似于Unix的管道操作) 宏引用,是从lisp quasiquote得来，还有逗号操作符.</p> <p>Elixir更新了AST机制 , 和Erlang AST独有展示的模式不同,<br> Elixir AST 统一了模式这使得meta-programming 更简单.</p> <p> 实现起来也中规中矩，只是有几处需要注意. 字符串插入 (主意不错) ：</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO<span class="class">.puts</span> <span class="string">"...#&#123;x&#125;..."</span></span><br></pre></td></tr></table></figure> <p>获取x并按格式打印出来. 但只对简单模式的x起作用.</p> <p> 这可以通过从Elixir调用Erlang的方法来弥补</p> <p> IO.puts “…#{pp(x)}…” 就可以. 只是需要把 pp(x) 改成</p> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">pp</span></span>(x) <span class="keyword">do</span> </span><br><span class="line">    <span class="symbol">:io_lib</span>.format(<span class="string">"~p"</span>, [x])</span><br><span class="line">    |&gt; <span class="symbol">:lists</span>.flatten</span><br><span class="line">    |&gt; <span class="symbol">:erlang</span>.list_to_binary</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> <p> Erlang 描述如下:</p> <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pp</span><span class="params">(<span class="variable">X</span>)</span> -&gt;</span></span><br><span class="line"> <span class="function_name">list_to_binary</span>(<span class="function_name">lists_flatten</span>(<span class="function_name">li_lib:format</span>(<span class="string">"~p),[X])))</span></span><br></pre></td></tr></table></figure> <p> 这和Elixir的描述一样. Elixir的写法也更容易阅读. |&gt; 操作符用来把io_lib:format 的结果输入到<br> lists:flatten 然后再到list_to_binary. 跟unix的管道符|一样</p> <p> Elixir区别与Erlang在 - 变量可复用.<br> 结果集始终可以表示为static-single-assignment (SSA) .<br> 但在循环结构里千万别这么做.好在 Elixir只用了递归而没有循环结构.<br> 如果循环结构里引用了可变的参数，那远端EVM就没法编译了.<br> 当在SSA顺序结构中使用变量时, EVM 就知道如何处理.循环结构Elixir就没办法了.<br> 其根源可追溯到LLVM汇编- 那就是另一个问题了.</p> <h2 id="编程语言设计的三定律">编程语言设计的三定律</h2><ul> <li><p>你做对的，无人为你提。</p> </li> <li><p>你做错的，有人跟你急。</p> </li> <li><p>难点必须不断重复解释。</p> </li> </ul> <p>有些语言在一些方面做得很好，它们正确，优雅，易于理解，但没人不辞麻烦地提及这些。</p> <p>错误的地方非常糟糕。你成了笨蛋，如果好处比重大于坏处，你可能被原谅。那些你想在以后消除的坏处，<br>却因为向后兼容性或者是有些傻子（或曰你的狂粉）已经用所有那些坏处写了无数行代码等原因，而不能动。</p> <p>难以理解的内容是真正倒霉的事情。你必须一遍又一遍地解释，直到你吐血，可还是有些人永远不懂，<br>你必须写上百邮件和数千文字来一遍又一遍地解释这些内容是什么意思以及它们为什么会如此。<br>对于一个语言的设计者或作者来说，这是一个痛苦的深渊。</p> <p>我将要提到的几件事就是我认为落入这三类情况中的。</p> <p>在我开始前，我要说 Elixir 做对了好多好多的事情，好处远远大于坏处。</p> <p>关于 Elixir 的好处是，及时改正它的坏处还不算晚。<br>这只能在无数代码行被写下和众多程序员开始使用它之前才能做到——所以只有少数时间来解决这些问题了。</p>]]></content>
    <summary type="html">
    <![CDATA[<p>大约一周前我开始学习Elixir. 关于这个我也只是有些模糊的印象但还没有仔细去看。</p> <p>但在Dave Thomas 出版了 <a href="https://pragprog.com/book/elixir/programming-elixir" target=]]>
    </summary>
    
      <category term="Elixir" scheme="http://zanjs.com/tags/Elixir/"/>
    
      <category term="erlang" scheme="http://zanjs.com/tags/erlang/"/>
    
      <category term="Elixir" scheme="http://zanjs.com/categories/Elixir/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MAC使用brew安装nginx+php+mysql环境]]></title>
    <link href="http://zanjs.com/2015/12/12/MAC%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85nginx-php-mysql%E7%8E%AF%E5%A2%83/"/>
    <id>http://zanjs.com/2015/12/12/MAC使用brew安装nginx-php-mysql环境/</id>
    <published>2015-12-12T07:31:01.000Z</published>
    <updated>2015-12-12T07:45:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装_homebrew">安装 homebrew</h2><blockquote> <p>参考资料：<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">http://brew.sh/index_zh-cn.html</a></p> </blockquote> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &#34;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&#34;</span><br></pre></td></tr></table></figure> <h2 id="安装_nginx">安装 nginx</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure> <h3 id="nginx_的操作命令：">nginx 的操作命令：</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$打开 nginx</span><br><span class="line">sudo nginx</span><br><span class="line">$重新加载配置|<span class="string">重启</span>|<span class="string">停止</span>|<span class="string">退出 nginx</span><br><span class="line">nginx -s reload</span>|<span class="string">reopen</span>|<span class="string">stop</span>|quit</span><br><span class="line">$测试配置是否有语法错误</span><br><span class="line">nginx -t</span><br></pre></td></tr></table></figure> <p>启动 nginx 后，默认的开启的是8080端口，可以通过修改配置文件来设置端口：</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>nginx<span class="regexp">/nginx.conf</span></span><br></pre></td></tr></table></figure> <p>默认访问的目录：</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>nginx<span class="regexp">/1.8.0/</span>html</span><br></pre></td></tr></table></figure> <h3 id="开机启动">开机启动</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="tag">p</span> ~/Library/LaunchAgents</span><br><span class="line">cp /usr/local/Cellar/nginx/<span class="number">1.8</span>.<span class="number">0</span>/homebrew<span class="class">.mxcl</span><span class="class">.nginx</span><span class="class">.plist</span> ~/Library/LaunchAgents/</span><br><span class="line">launchctl load -w ~/Library/LaunchAgents/homebrew<span class="class">.mxcl</span><span class="class">.nginx</span><span class="class">.plist</span></span><br></pre></td></tr></table></figure> <p>设置权限：</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown <span class="string">root:</span>wheel <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>nginx<span class="regexp">/1.8.0/</span>bin/nginx</span><br><span class="line">sudo chmod u+s <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>nginx<span class="regexp">/1.8.0/</span>bin/nginx</span><br></pre></td></tr></table></figure> <h2 id="安装mysql">安装mysql</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>install mysql</span><br></pre></td></tr></table></figure> <h3 id="配置mysql数据库：">配置mysql数据库：</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">mysql_install_db</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">user=`whoami`</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">basedir="$(brew</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">prefix</span> <span class="comment">mysql)"</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">datadir=/usr/local/var/mysql</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">tmpdir=/tmp</span></span><br></pre></td></tr></table></figure> <p>执行完成后就可以在终端中运行 mysql 命令了。</p> <p>这里需要注意一下，我们可以不需要密码就可以进入 mysql，可以通过一些安全设置、设置用户密码来保证安全性。</p> <p>设置 mysql 开机启动：</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="tag">p</span> ~/Library/LaunchAgents/</span><br><span class="line">cp /usr/local/Cellar/mysql/<span class="number">5.6</span>.<span class="number">17</span>/homebrew<span class="class">.mxcl</span><span class="class">.mysql</span><span class="class">.plist</span> ~/Library/LaunchAgents/</span><br><span class="line">launchctl load -w ~/Library/LaunchAgents/homebrew<span class="class">.mxcl</span><span class="class">.mysql</span><span class="class">.plist</span></span><br></pre></td></tr></table></figure> <p>mysql 配置文件：</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/my</span>sql<span class="regexp">/5.6.17/my</span>.cnf</span><br></pre></td></tr></table></figure> <h2 id="安装_php">安装 php</h2><p>MAC本来就自带了 php，但是很多扩展没有安装，所以选择了重新安装php。</p> <p>首先，我们需要安装第三方程序包。</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>tap homebrew/dupes</span><br><span class="line"><span class="keyword">brew </span>tap josegonzalez/homebrew-php</span><br></pre></td></tr></table></figure> <p>我们可以查看下 brew 下有那些 php 版本</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>search php</span><br></pre></td></tr></table></figure> <figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install php55 --<span class="keyword">with</span>-imap --<span class="keyword">with</span>-tidy --<span class="keyword">with</span>-<span class="keyword">debug</span> --<span class="keyword">with</span>-pgsql --<span class="keyword">with</span>-mysql --<span class="keyword">with</span>-fpm</span><br></pre></td></tr></table></figure> <p>更多的php选项可以通过以下命令查看：</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>options php55</span><br></pre></td></tr></table></figure> <p>由于是重装php，之前系统预装的php还没卸载，因此在终端调用php时，还是以之前系统的php版本做解析，<br>所以这里需要修改path，指定 php 的解析路径。在~/.bashrc（没有则创建）最后加入一行：</p> <p>export PATH=”$(brew –prefix php55)/bin:$PATH”</p> <p>执行一下 source 使之生效</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> ./.<span class="keyword">profile</span></span><br></pre></td></tr></table></figure> <p>php 配置文件：</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>php<span class="regexp">/5.5/</span>php.ini</span><br></pre></td></tr></table></figure> <p>php-fpm 配置文件：</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>php<span class="regexp">/5.5/</span>php-fpm.conf</span><br></pre></td></tr></table></figure> <p>启动 php-fpm 的话就直接在终端里执行 “php-fpm”，默认打开 php-fpm 会显示一个状态 shell 出来，<br>也可以把 php-fpm 的配置文件里的 “daemonize = no” 改为 “daemonize = yes”，就会以后台守护进程的方式启动，<br>对于刚修改的配置文件，可以执行 “php-fpm -t” 来检测配置有没有问题。</p> <p>开机启动php-fpm:</p> <p>mkdir -p ~/Library/LaunchAgents<br>cp /usr/local/Cellar/php55/5.5.26/homebrew-php.josegonzalez.php55.plist ~/Library/LaunchAgents/<br>launchctl load -w ~/Library/LaunchAgents/homebrew-php.josegonzalez.php55.plist</p>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装_homebrew">安装 homebrew</h2><blockquote> <p>参考资料：<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">http://br]]>
    </summary>
    
      <category term="mac" scheme="http://zanjs.com/tags/mac/"/>
    
      <category term="mysql" scheme="http://zanjs.com/tags/mysql/"/>
    
      <category term="nginx" scheme="http://zanjs.com/tags/nginx/"/>
    
      <category term="php" scheme="http://zanjs.com/tags/php/"/>
    
      <category term="php" scheme="http://zanjs.com/categories/php/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设置webpack实现React项目的hot load]]></title>
    <link href="http://zanjs.com/2015/11/22/%E8%AE%BE%E7%BD%AEwebpack%E5%AE%9E%E7%8E%B0React%E9%A1%B9%E7%9B%AE%E7%9A%84hot-load/"/>
    <id>http://zanjs.com/2015/11/22/设置webpack实现React项目的hot-load/</id>
    <published>2015-11-22T05:38:36.000Z</published>
    <updated>2015-11-22T05:50:30.000Z</updated>
    <content type="html"><![CDATA[<p>编写了简单的项目: <a href="https://github.com/MarshalW/react-proto/tree/m1" target="_blank" rel="external">react-proto m1</a>。用来说明如何设置简单的React开发环境。<br>通过webpack及其插件 <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="external">react-hot-loader</a>，实现js/jsx代码修改后，浏览器中的网页能自动加载js。</p> <h2 id="准备工作">准备工作</h2><p>安装webpack，见 <a href="http://webpack.github.io/docs/tutorials/getting-started/" target="_blank" rel="external">webpack getting started</a>。</p> <h2 id="导入项目及运行">导入项目及运行</h2><p>见这里：<a href="https://github.com/MarshalW/react-proto/blob/master/README.md#%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C" target="_blank" rel="external">README.md#安装与运行</a>。</p> <p>运行的截图：</p> <p><img src="http://marshal.ohtly.com/images/browser-react-hot-loader.png" alt="react"></p> <p>相关文件的说明</p> <ul> <li>webpack.config.js：webpack的配置文件</li> <li>server.js：用于开发阶段测试使用的webserver</li> <li>index.html：webapp的网页</li> <li>scripts目录：存放js脚本<ul> <li>index.js：js入口文件</li> <li>App.js：webapp js的入口文件，这里使用了ES6的语法，webpack使用了babel将ES6语法代码转换成ES5的代码</li> </ul> </li> </ul>]]></content>
    <summary type="html">
    <![CDATA[<p>编写了简单的项目: <a href="https://github.com/MarshalW/react-proto/tree/m1" target="_blank" rel="external">react-proto m1</a>。用来说明如何设置简单的React开发环]]>
    </summary>
    
      <category term="javascript" scheme="http://zanjs.com/tags/javascript/"/>
    
      <category term="react" scheme="http://zanjs.com/tags/react/"/>
    
      <category term="webpack" scheme="http://zanjs.com/tags/webpack/"/>
    
      <category term="javascript" scheme="http://zanjs.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Create a character voting app using React, Node.js, MongoDB and Socket.IO]]></title>
    <link href="http://zanjs.com/2015/11/21/Create-a-character-voting-app-using-React-Node-js-MongoDB-and-Socket-IO/"/>
    <id>http://zanjs.com/2015/11/21/Create-a-character-voting-app-using-React-Node-js-MongoDB-and-Socket-IO/</id>
    <published>2015-11-21T03:38:11.000Z</published>
    <updated>2015-11-21T03:49:31.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Update_Notice_2_(November_12,_2015)">Update Notice 2 (November 12, 2015)</h3><p>Tutorial has been updated to use <a href="https://medium.com/@malyw/how-to-update-babel-5-x-6-x-d828c230ec53" target="_blank" rel="external">Babel</a> 6.0 and<br> React <a href="https://github.com/rackt/react-router/releases/tag/v1.0.0" target="_blank" rel="external">Router 1.0</a>. For detailed tutorial updates see November 12, 2015 notes below.</p> <h3 id="Update_Notice_1_(October_19,_2015)">Update Notice 1 (October 19, 2015)</h3><p>Tutorial has been updated to use React 0.14 and React Router 1.0-rc3 that introduced breaking changes.<br>For detailed tutorial updates see October 19, 2015 notes below.</p> <h2 id="Overview">Overview</h2><p>In this tutorial we are going to build a character voting app (inspired by Facemash and Hot or Not)<br>for <a href="http://www.eveonline.com/" target="_blank" rel="external">EVE Online</a> - a massively multiplayer online game.<br>Be sure to play this awesome soundtrack below to get yourself in the mood for this epicly long tutorial.</p> <p>While listening to this soundtrack, imagine yourself mining asteroid belts in deep space while<br>keeping a lookout for pirates on the radar, researching propulsion system blueprints at the station’s facility,<br>manufacturing spaceship components for capital ships, placing buy &amp; sell orders on the entirely<br>player-driven market where supply and demand govern the game economics, hauling trade goods from a remote solar system<br>in a massive freighter, flying blazingly fast interceptors with a microwarpdrive or powerful battleships armored to<br>the teeth, optimizing extraction efficiency of rare minerals from planets,<br>or fighting large-scale battles with thousands of players from multiple alliances. That is <strong><em> EVE Online </em></strong>.</p> <p>Each player in EVE Online has a 3D avatar representing their character.<br>This app is designed for ranking those avatars. Anyway, your goal here is to learn about Node.js,<br>React and Flux, not EVE Online. But I will say this: “Having an interesting tutorial project is just as important,<br>if not more so, than the main subject of the tutorial”.<br>The only reason I built the original New Eden Faces app is to learn Backbone.js and the only reason I built the<br> TV Show Tracker app is so that I could learn AngularJS. To me, either one of these projects is far more<br> interesting than a simple todo app that everyone seems to be using these days.</p> <p> One thing that I have learned — between screencasts, books and training videos,<br> nothing is more effective than building a small project that you are passionate about to learn a new technology.</p>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Update_Notice_2_(November_12,_2015)">Update Notice 2 (November 12, 2015)</h3><p>Tutorial has been updated to use <a href="https://me]]>
    </summary>
    
      <category term="javascript" scheme="http://zanjs.com/tags/javascript/"/>
    
      <category term="mongodb" scheme="http://zanjs.com/tags/mongodb/"/>
    
      <category term="nodejs" scheme="http://zanjs.com/tags/nodejs/"/>
    
      <category term="react" scheme="http://zanjs.com/tags/react/"/>
    
      <category term="socket.io" scheme="http://zanjs.com/tags/socket-io/"/>
    
      <category term="javascript" scheme="http://zanjs.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 异步方案 async/await]]></title>
    <link href="http://zanjs.com/2015/11/20/JavaScript-%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88-async-await/"/>
    <id>http://zanjs.com/2015/11/20/JavaScript-异步方案-async-await/</id>
    <published>2015-11-20T13:57:18.000Z</published>
    <updated>2015-11-20T14:17:55.000Z</updated>
    <content type="html"><![CDATA[<p>构建一个应用程序总是会面对异步调用，不论是在 Web 前端界面，还是 Node.js 服务端都是如此，JavaScript 里面处理异步调用一直是非常恶心的一件事情。<br>以前只能通过回调函数，后来渐渐又演化出来很多方案，最后 Promise 以简单、易用、兼容性好取胜，但是仍然有非常多的问题。<br>其实 JavaScript 一直想在语言层面彻底解决这个问题，在 ES6 中就已经支持原生的 Promise，还引入了 Generator 函数，终于在 ES7 中决定支持 async 和 await。</p> <h2 id="基本语法">基本语法</h2><p>async/await 究竟是怎么解决异步调用的写法呢？简单来说，就是将异步操作用同步的写法来写。先来看下最基本的语法（ES7 代码片段）：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> t = <span class="keyword">await</span> f();</span><br><span class="line">  <span class="built_in">console</span>.log(t);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testAsync();</span><br></pre></td></tr></table></figure> <p>首先定义了一个函数 <code>f</code>，这个函数返回一个 <code>Promise</code>，并且会延时 2 秒，<code>resolve</code> 并且传入值 123。<code>testAsync</code> 函数在定义时使用了关键字 <code>async</code>，<br>然后函数体中配合使用了 <code>await</code>，最后执行 <code>testAsync</code>。整个程序会在 2 秒后输出 123，也就是说 <code>testAsync</code> 中常量 t 取得了 <code>f</code>中 <code>resolve</code> 的值，<br>并且通过 <code>await</code> 阻塞了后面代码的执行，直到 <code>f</code>这个异步函数执行完。</p> <h2 id="对比_Promise">对比 Promise</h2><p>仅仅是一个简单的调用，就已经能够看出来 <code>async/await</code> 的强大，写码时可以非常优雅地处理异步函数，彻底告别回调恶梦和无数的 then 方法。<br>我们再来看下与 <code>Promise</code> 的对比，同样的代码，如果完全使用 <code>Promise</code> 会有什么问题呢？</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testAsync = () =&gt; &#123;</span><br><span class="line">  f().then((t) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(t);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testAsync();</span><br></pre></td></tr></table></figure> <p>从代码片段中不难看出 <code>Promise</code> 没有解决好的事情，比如要有很多的 then 方法，整块代码会充满 <code>Promise</code> 的方法，而不是业务逻辑本身，<br>而且每一个 <code>then</code> 方法内部是一个独立的作用域，要是想共享数据，就要将部分数据暴露在最外层，在 then 内部赋值一次。<br>虽然如此，<code>Promise</code> 对于异步操作的封装还是非常不错的，所以 <code>async/await</code> 是基于 <code>Promise</code> 的，await 后面是要接收一个 Promise 实例。</p> <h2 id="对比_RxJS">对比 RxJS</h2><p>RxJS 也是非常有意思的东西，用来处理异步操作，它更能处理基于流的数据操作。<br>举个例子，比如在 Angular2 中 http 请求返回的就是一个 RxJS 构造的 Observable Object，我们就可以这样做：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$http.get(url)</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value !== <span class="literal">null</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'do something.'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure> <p>如果是 ES6 代码可以进一步简洁：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$http.get(url) </span><br><span class="line">  .map(value =&gt; value + <span class="number">1</span>) </span><br><span class="line">  .filter(value =&gt; value !== <span class="literal">null</span>) </span><br><span class="line">  .forEach(value =&gt; <span class="built_in">console</span>.log(value)) </span><br><span class="line">  .subscribe((value) =&gt; &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'do something.'</span>); </span><br><span class="line">  &#125;, (err) =&gt; &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(err); </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure> <p>可以看出 RxJS 对于这类数据可以做一种类似流式的处理，也是非常优雅，<br>而且 RxJS 强大之处在于你还可以对数据做取消、监听、节流等等的操作，这里不一一举例了，感兴趣的话可以去看下 RxJS 的 API。</p> <p>这里要说明一下的就是 RxJS 和 async/await 一起用也是可以的，Observable Object 中有 toPromise 方法，可以返回一个 Promise Object，<br>同样可以结合 await 使用。<br>当然你也可以只使用 async/await 配合 underscore 或者其他库，也能实现很优雅的效果。总之，RxJS 与 async/await 不冲突。</p> <h2 id="异常处理">异常处理</h2><p>通过使用 async/await，我们就可以配合 try/catch 来捕获异步操作过程中的问题，包括 Promise 中 reject 的数据。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      reject(<span class="number">234</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testAsync = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> t = <span class="keyword">await</span> f();</span><br><span class="line">    <span class="built_in">console</span>.log(t);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testAsync();</span><br></pre></td></tr></table></figure> <p>代码片段中将 f 方法中的 <code>resolve</code> 改为 reject，在 testAsync 中，通过 <code>catch</code> 可以捕获到 <code>reject</code> 的数据，输出 err 的值为 234。<br><code>try/catch</code> 使用时也要注意范围和层级。如果 try 范围内包含多个 await，那么 catch 会返回第一个 <code>reject</code> 的值或错误。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      reject(<span class="number">111</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f2 = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      reject(<span class="number">222</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testAsync = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> t1 = <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="built_in">console</span>.log(t1);</span><br><span class="line">    <span class="keyword">const</span> t2 = <span class="keyword">await</span> f2();</span><br><span class="line">    <span class="built_in">console</span>.log(t2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testAsync();</span><br></pre></td></tr></table></figure> <p>如代码片段所示，testAsync 函数体中 try 有两个 await 函数，而且都分别 reject，那么 catch 中仅会触发 f1 的 reject，输出的 err 值是 111。</p> <h2 id="开始使用">开始使用</h2><p>无论是 Web 前端还是 Node.js 服务端，都可以通过预编译的手段实现使用 ES6 和 ES7 来写代码，<br>目前最流行的方案是通过 Babel 将使用 ES7、ES6 写的代码编译为 E6 或 ES5 的代码来执行。</p> <h2 id="Node-js_服务端配置">Node.js 服务端配置</h2><p>服务端使用 Babel，最简单的方式是通过 require hook。</p> <p>首先安装 Babel：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core --save</span><br></pre></td></tr></table></figure> <p>安装 async/await 支持：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-preset-stage-3 --save</span><br></pre></td></tr></table></figure> <p>在服务端代码的根目录中配置 .babelrc 文件，内容为：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">presets</span>": <span class="value">[<span class="string">"stage-3"</span>]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure> <p>在顶层代码文件（server.js 或 app.js 等）中引入 Babel 模块：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"babel-core/register"</span>);</span><br></pre></td></tr></table></figure> <p>在这句后面引入的模块，都将会自动通过 babel 编译，但当前文件不会被 babel 编译。<br>另外，需要注意 Node.js 的版本，如果是 4.0 以上的版本则默认支持绝大部分 ES6，可以直接启动。<br>但是如果是 0.12 左右的版本，就需要通过 node —harmory 来启动才能够支持。因为 stage-3 模式，Babel 不会编译基本的 ES6 代码，<br>环境既然支持又何必要编译为 ES5？这样做也是为了提高性能和编译效率。</p> <h2 id="配置_Web_前端构建">配置 Web 前端构建</h2><p>可以通过增加 Gulp 的预编译 task 来支持。</p> <p>首先安装 gulp-babel 插件：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-babel --save-dev</span><br></pre></td></tr></table></figure> <p>然后编写配置：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'babel'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/app.js'</span>)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>除了 Gulp-babel 插件，也可以使用官方的 Babel-loader 结合 Webpack 或 Browserify 使用。</p>]]></content>
    <summary type="html">
    <![CDATA[<p>构建一个应用程序总是会面对异步调用，不论是在 Web 前端界面，还是 Node.js 服务端都是如此，JavaScript 里面处理异步调用一直是非常恶心的一件事情。<br>以前只能通过回调函数，后来渐渐又演化出来很多方案，最后 Promise 以简单、易用、兼容性好取胜，]]>
    </summary>
    
      <category term="async" scheme="http://zanjs.com/tags/async/"/>
    
      <category term="javascript" scheme="http://zanjs.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://zanjs.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OX上安装MongoDb]]></title>
    <link href="http://zanjs.com/2015/10/31/Mac-OX%E4%B8%8A%E5%AE%89%E8%A3%85MongoDb/"/>
    <id>http://zanjs.com/2015/10/31/Mac-OX上安装MongoDb/</id>
    <published>2015-10-31T00:53:53.000Z</published>
    <updated>2015-12-21T05:44:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="install_MongoDb">install MongoDb</h2><blockquote> <p>更新Homebrew的package数据库，在Mac的终端中输入：</p> </blockquote> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>update</span><br></pre></td></tr></table></figure> <p>然后</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>install mongodb</span><br></pre></td></tr></table></figure> <p>等待MongoDb下载完成。这个比较贴心了，有下载进度百分比。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julauddeMacBook-Pro:/ julaud$ brew install mongodb</span><br><span class="line">==&gt; Downloading https:<span class="comment">//homebrew.bintray.com/bottles/mongodb-3.0.7.yosemite.bott</span></span><br><span class="line">Already downloaded: /Library/Caches/Homebrew/mongodb-<span class="number">3.0</span>.<span class="number">7</span><span class="class">.yosemite</span><span class="class">.bottle</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line">==&gt; Pouring mongodb-<span class="number">3.0</span>.<span class="number">7</span><span class="class">.yosemite</span><span class="class">.bottle</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line">==&gt; Caveats</span><br><span class="line">To have launchd start mongodb at login:</span><br><span class="line">  ln -sfv /usr/local/opt/mongodb<span class="comment">/*.plist ~/Library/LaunchAgents</span><br><span class="line">Then to load mongodb now:</span><br><span class="line">  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mongodb.plist</span><br><span class="line">Or, if you don't want/need launchctl, you can just run:</span><br><span class="line">  mongod --config /usr/local/etc/mongod.conf</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/mongodb/3.0.7: 17 files, 158M</span></span><br></pre></td></tr></table></figure> <h2 id="启动MongoDb">启动MongoDb</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">🍺  <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>mongodb/<span class="number">3.0</span><span class="number">.7</span>: <span class="number">17</span> files, <span class="number">158</span>M</span><br><span class="line">julauddeMacBook-<span class="string">Pro:</span><span class="regexp">/ julaud$ mongod --config /</span>usr<span class="regexp">/local/</span>etc/mongod.conf</span><br></pre></td></tr></table></figure> <p>运行mongodb执行 mongod命令就可以<br>mongod –dbpath=/data/db</p> <h2 id="连接MongoDb">连接MongoDb</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Oct <span class="number">29</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">01</span> on ttys000</span><br><span class="line">julauddeMacBook-Pro:~ julaud$ mongo</span><br><span class="line">MongoDB shell version: <span class="number">3.0</span><span class="number">.7</span></span><br><span class="line">connecting to: test</span><br><span class="line">Welcome to the MongoDB shell.</span><br><span class="line">For interactive help, type <span class="string">"help"</span>.</span><br><span class="line">For more comprehensive documentation, see</span><br><span class="line">	http:<span class="comment">//docs.mongodb.org/</span></span><br><span class="line">Questions? Try the support group</span><br><span class="line">	http:<span class="comment">//groups.google.com/group/mongodb-user</span></span><br><span class="line">Server has startup warnings:</span><br><span class="line"><span class="number">2015</span>-<span class="number">10</span>-<span class="number">30</span>T22:<span class="number">55</span>:<span class="number">29.874</span>+<span class="number">0800</span> I CONTROL  [initandlisten]</span><br><span class="line"><span class="number">2015</span>-<span class="number">10</span>-<span class="number">30</span>T22:<span class="number">55</span>:<span class="number">29.874</span>+<span class="number">0800</span> I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is <span class="number">256</span>, should be at least <span class="number">1000</span></span><br><span class="line">&gt; show dbs</span><br><span class="line">local  <span class="number">0.078</span>GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="install_MongoDb">install MongoDb</h2><blockquote> <p>更新Homebrew的package数据库，在Mac的终端中输入：</p> </blockquote> <figure class="highlight ar]]>
    </summary>
    
      <category term="mac" scheme="http://zanjs.com/tags/mac/"/>
    
      <category term="mongodb" scheme="http://zanjs.com/tags/mongodb/"/>
    
      <category term="数据库" scheme="http://zanjs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库" scheme="http://zanjs.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浏览器同步测试工具Browsersync | 前端开发神器]]></title>
    <link href="http://zanjs.com/2015/10/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%AD%A5%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Browsersync/"/>
    <id>http://zanjs.com/2015/10/26/浏览器同步测试工具Browsersync/</id>
    <published>2015-10-26T12:39:40.000Z</published>
    <updated>2015-11-20T13:27:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="省时的浏览器同步测试工具">省时的浏览器同步测试工具</h2><blockquote> <p>Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。<br>更重要的是Browsersync可以同时在PC、平板、手机等设备下进项调试。<br>您可以想象一下：“假设您的桌子上有pc、ipad、iphone、android等设备，同时打开了您需要调试的页面，<br>当您使用browsersync后，您的任何一次代码保存，以上的设备都会同时显示您的改动”。<br>无论您是前端还是后端工程师，使用它将提高您30%的工作效率。</p> </blockquote> <p><img src="http://zanjs.b0.upaiyun.com/image/8/89/55a39bc2736a6f8d306d0c92e1df0.gif" alt="同步浏览"></p>  <p>有了它，您不用在多个浏览器、多个设备间来回切换，频繁的刷新页面。<br>更神奇的是您在一个浏览器中滚动页面、点击等行为也会同步到其他浏览器和设备中，这一切还可以通过可视化界面来控制。</p> <p><img src="http://zanjs.b0.upaiyun.com/image/1/c4/aceebbaf49ede7e599027d0d48565.gif" alt="同步测试"></p> <h2 id="您不可或缺的测试助手">您不可或缺的测试助手</h2><h3 id="简化操作流程">简化操作流程</h3><p>每个网页在不同设备的浏览器里，测试时间呈指数级增长，无论是PC还是移动端。<br>曾经我们每改一次的代码，都需要手动去刷新一次页面，查看我们的改动是否正确；<br>现在，BrowserSync减少了重复的手工任务，这一切都交给BrowserSync去完成，我们只需专注在业务的逻辑里去。</p> <h3 id="工作中您需要它">工作中您需要它</h3><p>BrowserSync是建立在网络技术上的，您可以轻松安装在OS X，Windows或Linux上，然后在不同的设备及浏览器里进行调试。<br>就连UI都可以运行在浏览器 - 尝试在另一台设备上创建第二页面来控制您的BrowserSync。</p> <h3 id="插入到您的工作流程">插入到您的工作流程</h3><p>通过可视化的操作方式或命令行来创建个性化的测试环境，多设备共同响应。<br>BrowserSync很容易与您的网络平台集成，构建工具和其他Node项目中，例如gulp、grunt。</p> <h2 id="更多功能的加入，完全免费。">更多功能的加入，完全免费。</h2><h3 id="交互同步">交互同步</h3><p>您的滚动，点击，刷新等操作可以在不同浏览器之间同步更新。</p> <h3 id="文件同步">文件同步</h3><p>当您改变HTML，CSS，图像和其他项目文件浏览器会自动更新。</p> <h3 id="URL历史_NEW">URL历史 NEW</h3><p>记录您的测试网址，您只需点击一次，就可以在不同设备里访问。</p> <h3 id="同步定制_NEW">同步定制 NEW</h3><p>切换各个同步设置创建您的首选测试环境。</p> <h3 id="远程督察_NEW">远程督察 NEW</h3><p>远程调整和正在对连接的设备运行调试网页。</p> <h3 id="URL通道_NEW">URL通道 NEW</h3><p>创建一个安全的公共URL分享您的本地站点，任何设备都可以访问它，并可以响应您的任何改动。</p> <h3 id="UI或命令行控制_NEW">UI或命令行控制 NEW</h3><p>使用可视化页面来进行相关设置，也可以使用命令行来完成。</p> <h3 id="浏览器支持">浏览器支持</h3><p>支持PC，平板电脑和手机之间的即时同步。各种文件及时响应，堪称完美。</p> <h3 id="构建工具兼容">构建工具兼容</h3><p>可轻松与grunt、gulp等工具配合使用，或包含在其它node项目里。</p> <h3 id="服务于任何本地站点">服务于任何本地站点</h3><p>可以在PHP，ASP，Rails和更多网站运行使用。也可以创建静态环境。</p> <h3 id="安装并运行在任何地方">安装并运行在任何地方</h3><p>基于Node.js并支持Windows，MacOS和Linux操作系统，设置只需要5分钟。</p> <h3 id="空闲运行并再利用">空闲运行并再利用</h3><p>浏览器同步是一个开源项目，可根据Apache2.0许可使用或更改。</p> <h2 id="5分钟快速入门">5分钟快速入门</h2><ol> <li>安装 Node.js</li> </ol> <p>BrowserSync是基于Node.js的, 是一个Node模块， 如果您想要快速使用它，也许您需要先安装一下Node.js</p> <p><a href="http://nodejs.org/download/" target="_blank" rel="external">安装适用于Mac OS，Windows和Linux。</a></p> <ol> <li>安装 BrowserSync</li> </ol> <p>您可以选择从Node.js的包管理（NPM）<a href="https://npmjs.org/package/browser-sync" target="_blank" rel="external">库中</a> 安装BrowserSync。<br>打开一个终端窗口，运行以下命令：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> browser-<span class="keyword">sync</span></span></span><br></pre></td></tr></table></figure> <blockquote> <p>您告诉包管理器下载BrowserSync文件，并在全局下安装它们，您可以在所有项目(任何目录)中使用。</p> </blockquote> <p>当然您也可以结合<code>gulpjs</code>或<code>gruntjs</code>构建工具来使用，在您需要构建的项目里运行下面的命令:</p> <figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> browser-sync</span><br></pre></td></tr></table></figure> <ol> <li>启动 BrowserSync</li> </ol> <p>一个基本用途是，如果您只希望在对某个css文件进行修改后会同步到浏览器里。<br>那么您只需要运行命令行工具，进入到该项目（目录）下，并运行相应的命令：</p> <blockquote> <p>静态网站</p> </blockquote> <p>如果您想要监听.css文件, 您需要使用服务器模式。 BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站。</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// --<span class="keyword">files</span> 路径是相对于运行该命令的项目（目录）</span><br><span class="line">browser-<span class="keyword">sync</span> start --server --<span class="keyword">files</span> <span class="string">"css/*.css"</span></span><br></pre></td></tr></table></figure> <p>如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// --<span class="keyword">files</span> 路径是相对于运行该命令的项目（目录）</span><br><span class="line">browser-<span class="keyword">sync</span> start --server --<span class="keyword">files</span> <span class="string">"css/*.css, *.html"</span></span><br><span class="line">// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。</span><br><span class="line">browser-<span class="keyword">sync</span> start --server --<span class="keyword">files</span> <span class="string">"**/*.css, **/*.html"</span></span><br></pre></td></tr></table></figure> <p>我们做了一个静态例子的示范，您可以下载示例包，文件您可以解压任何盘符的任何目录下，不能是中文路径。<br>打开您的命令行工具，进入到BrowsersyncExample目录下，运行以下其中一条命令。<br>Browsersync将创建一个本地服务器并自动打开你的浏览器后访问<a href="http://localhost:3000地址，这一切都会在命令行工具里显示。" target="_blank" rel="external">http://localhost:3000地址，这一切都会在命令行工具里显示。</a><br>你也可以查看Browsersync静态示例视频</p> <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听css文件</span></span><br><span class="line">browser-sync start --<span class="keyword">server</span> --files <span class="string">"css/*.css"</span></span><br><span class="line"><span class="comment">// 监听css和html文件</span></span><br><span class="line">browser-sync start --<span class="keyword">server</span> --files <span class="string">"css/*.css, *.html"</span></span><br></pre></td></tr></table></figure> <blockquote> <p>动态网站</p> </blockquote> <p>如果您已经有其他本地服务器环境PHP或类似的，您需要使用代理模式。<br>BrowserSync将通过代理URL(localhost:3000)来查看您的网站。</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主机名可以是<span class="literal">ip</span>或域名</span><br><span class="line"><span class="keyword">browser-sync </span>start --proxy <span class="string">"主机名"</span> <span class="string">"css/*.css"</span></span><br></pre></td></tr></table></figure> <p>在本地创建了一个PHP服务器环境，并通过绑定Browsersync.cn来访问本地服务器，<br>使用以下命令方式，Browsersync将提供一个新的地址localhost:3000来访问Browsersync.cn，并监听其css目录下的所有css文件。</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">browser-sync </span>start --proxy <span class="string">"Browsersync.cn"</span> <span class="string">"css/*.css"</span></span><br></pre></td></tr></table></figure> <p>一点建议</p> <p>我们建议您结合gulp或grunt来使用，我们这里有详细说明Gulp文档、Grunt文档。<br>如果您还没有使用gulp或grunt，那么可以通过以上方式创建Browsersync</p>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="省时的浏览器同步测试工具">省时的浏览器同步测试工具</h2><blockquote> <p>Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。<br>更重要的是Browsersync可以同时]]>
    </summary>
    
      <category term="Browsersync" scheme="http://zanjs.com/tags/Browsersync/"/>
    
      <category term="前端开发工具" scheme="http://zanjs.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发工具" scheme="http://zanjs.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发工具" scheme="http://zanjs.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[atom使用帮助]]></title>
    <link href="http://zanjs.com/2015/10/25/atom%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/"/>
    <id>http://zanjs.com/2015/10/25/atom使用帮助/</id>
    <published>2015-10-25T10:30:37.000Z</published>
    <updated>2015-11-20T13:27:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Atom">Atom</h2><p>一款编辑器入门还是很简单的，学会怎么样创建，打开，编辑，保存文件就行。<br>剩下的就是慢慢熟悉，Atom 会不断带给你惊喜，如果你想简化或者加快平时工作中的某些任务或者动作，你就可以去搜索一下，Atom 要么本身就为你提供你需要的功能，没有的话，也可以通过现成的插件（Packages）或者自定义的方式解决。</p> <h2 id="安装">安装</h2><p>如果你顺着我们的路线走过来，你的电脑上应该已经安装好了系统的包管理工具，<br>Windows 上的 Chocolatey，Mac 上的 Homebrew，Atom 编辑器可以通过包管理工具来安装。</p>  <h3 id="Windows">Windows</h3><p>用管理员的身份打开 Powershell，然后用 choco install 去安装 Atom：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco <span class="keyword">install</span> atom</span><br></pre></td></tr></table></figure> <blockquote> <p>提示：Atom 编辑器体积挺大，在国内由于网络环境问题，在下载的时候会比较慢，<br>有时也可能出现不能连接到远程服务器的错误，解决的方法就是，准备 “梯子” 。</p> </blockquote> <h3 id="Mac">Mac</h3><p>打开系统的 终端，然后用 Homebrew 的 brew install 命令去安装 Atom：</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>install Caskroom/cask/atom</span><br></pre></td></tr></table></figure> <p>在命令行下面安装完 Atom 以后，可以输入 atom ，后面指定一个目录，这样会用 Atom 编辑器打开这个目录。<br>另外 Atom 编辑器还自带了一个包管理工具叫 apm （Atom Package Manager），<br>用这个工具可以在命令行下面为编辑器去安装包 （Package） ，包就是 Atom 的插件。</p> <h2 id="Packages">Packages</h2><p>Atom 核心的功能是由 Core Packages（核心包） 提供的，另外还有 Community Packages（社区包），<br>就是由社区成员自己开发并且分享出来的 Package。Atom 可以通过安装这些 Package 来扩展编辑器的功能。<br>安装 Package 可以在 Atom 的配置界面上去搜索，然后安装，也可以使用 apm 在命令行下面管理编辑器的 Package 。</p> <p>Packages 列表：<a href="https://atom.io/packages" target="_blank" rel="external">https://atom.io/packages</a></p> <p><img src="http://zanjs.b0.upaiyun.com/image/a/0f/ae18039ff2750d0a0d7de123108a4.png" alt="atom"></p> <h3 id="安装包：通过配置界面">安装包：通过配置界面</h3><ul> <li>打开 Atom 编辑器。</li> <li>打开 Atom 的配置界面（Windows：ctrl + , Mac：command + , ）。</li> <li>点击边栏上的 Install（安装）。</li> <li>在界面上的 Install Packages 下面，选中 Packages 标签，然后搜索你想要安装的 Package。</li> <li>在搜索结果找到想要的 Package ，点击 Install 安装。</li> </ul> <p><img src="http://zanjs.b0.upaiyun.com/image/5/bb/f3f7dd7cd5ca08f8d523840d1cc2e.png" alt="atom 编辑器"></p> <h3 id="安装包：通过_apm">安装包：通过 apm</h3><ul> <li>打开命令行工具，Windows 用 Powershell，Mac 可以使用终端。</li> <li>搜索包用的是 apm search &lt;关键词&gt; 。</li> <li>找到想要的包以后，再用 apm install &lt;包的名字&gt;。</li> </ul> <blockquote> <p>下面，你可以搜索一个叫 Localization 的包，然后安装一下，这个包会为 Atom 的菜单栏提供一个中文翻译。<br>下面我们再看一下怎么样去配置与管理包。</p> </blockquote> <h2 id="管理包">管理包</h2><p>打开配置界面，在边栏上选中 Packages ，在这个界面上的 Communtity Packages 区域里，你可以找到自己安装的来自社区成员分享的包。<br>Core Packages 下面是 Atom 编辑器核心自带的包。</p> <p><img src="http://zanjs.b0.upaiyun.com/image/d/a6/62c3be1ede689b80f9b3d9595fa7f.png" alt=""></p> <p>这里会显示包的名字，还有介绍，不想用的包，可以点击 Disable 按钮禁用它，或者直接点击 Uninstall 卸载掉包，点击 Settings 按钮可以打开包的配置界面，在这个界面上，你可以找到包的主页，说明的文档，可以查看包的源文件，还有相关的配置与快捷键。</p> <p>下面打开之前安装的 Localization 这个包的配置界面，然后在 Settings 区域里面，在 Current Language 下面的文本框里输入：Chinese - Simplified ，这样会把菜单栏的语言设置成简体中文，如果设置成 Chinese - Traditional，会把菜单栏设置成繁体中文。输入以后，用鼠标点一下浏览器的其它的地方，这样编辑器会保存你的配置。</p> <p>完成以后，想让设置生效，可以关掉并且重新打开编辑器，或者可以刷新一下编辑器。</p> <blockquote> <p>刷新编辑器的快捷键：</p> </blockquote> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mac</span>    ：ctrl + alt + command + <span class="keyword">L</span></span><br><span class="line">Windows：ctrl + alt + <span class="literal">R</span></span><br></pre></td></tr></table></figure> <h2 id="基础">基础</h2><p>编辑器没有使用的门槛，打开以后，你就已经知道怎么用了，不过有些小技巧可以了解一下，可以提高工作效率。<br>先去下载点东西，HTML5Boilerplate（<a href="https://html5boilerplate.com/），这个东西可以作为项目的基础，" target="_blank" rel="external">https://html5boilerplate.com/），这个东西可以作为项目的基础，</a><br>以后我们会再跟它见面，以后在介绍前端包管理的时候，这个下载的动作可以用命令去做。<br>下载以后，解压一下，把解压以后的目录重命名成你自己想要创建的项目的名字，<br>然后用编辑器打开这个项目的目录（<code>Ｍac：command + O，Windows：ctrl + shift + O</code>）。</p> <p><img src="http://zanjs.b0.upaiyun.com/image/c/2e/7334fcbcd7a81d474c014bacd030f.png" alt=""></p> <p>编辑器的工作区有两部分组成，左边是编辑器的 Tree View（树形视图），上面会显示你打开的目录里面的东西，<br>右边是编辑器，在这可以处理打开的文件，最上面是标签栏，点击不同的标签可以打开对应的文件。</p> <h2 id="树形视图">树形视图</h2><p>你想打开在树形视图上的文件，创建新的文件或者目录，展开与收起目录，这些动作可以用鼠标完成，或者也可以使用键盘上的按键。<br>想要在树形视图上操作，你需要把焦点放到树形视图上，切换焦点使用 ctrl + 0 。<br>你会发现树形视图上的背景颜色会有点变化，具体是什么变化，取决于你的编辑器使用的主题。</p> <p>查看跟树形视图相关的命令，先确定你的焦点在树形视图上，然后打开命令面板（Command Palette），用快捷键：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="built_in">command</span> + <span class="built_in">shift</span> + P</span><br><span class="line">Windows：ctrl + <span class="built_in">shift</span> + P</span><br></pre></td></tr></table></figure> <p>搜索一下 tree view ，列出的就是跟树形视图相关的命令。</p> <p><img src="http://zanjs.b0.upaiyun.com/image/e/c4/1d687351bddbb3ba974a9f5342657.png" alt="tree view "></p> <ul> <li>向下移动：↓ 或 J</li> <li>向上移动：↑ 或 K</li> <li>展开目录：→ 或 L</li> <li>收起目录：← 或 H</li> <li>打开文件：enter 回车</li> </ul> <blockquote> <p>多试几次上面的快捷键，把它变成自己的肌肉记忆。</p> </blockquote> <h2 id="编辑器">编辑器</h2><p>先随便打开几个项目里的文件，比如 humans.txt，index.html，还有 css/main.css 。<br>打开的文件会出现在编辑器的标签栏上，除了用鼠标点击标签可以打开对应的文件，也可以使用快捷键：</p> <p>打开下一个标签面板</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：alt + <span class="command"><span class="keyword">command</span> + →</span></span><br><span class="line">Windows：ctrl + pagedown</span><br></pre></td></tr></table></figure> <p>打开上一个标签面板</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：alt + <span class="command"><span class="keyword">command</span> + ←</span></span><br><span class="line">Windows：ctrl + pageup</span><br></pre></td></tr></table></figure> <blockquote> <p>在 Mac 上，你还可以使用 command + 数字 ，打开对应的标签面板。</p> </blockquote> <p>关闭标签面板</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mac</span>    ：command + <span class="literal">W</span></span><br><span class="line">Windows：ctrl + <span class="literal">W</span></span><br></pre></td></tr></table></figure> <h2 id="分离面板">分离面板</h2><p>在编辑器上打开的文件可以分离到不同的面板上显示，你可以把编辑器分隔成上，下，左，右，四个部分。<br>方法是，找到要分离显示的标签面板，鼠标右键点击，然后选择 Split Up，Split Down，Split Left 或者 Split Right。</p> <p><img src="http://zanjs.b0.upaiyun.com/image/2/a4/8a77269fd1060245153c88b0bb187.png" alt=""></p> <p>这些动作也都有对应的快捷键，可以打开命令面板（Mac：command + shift + P，Windows：ctrl + shift + P），<br>然后搜索 Pane ，这样会显示出面板相关的操作命令。</p> <blockquote> <p>分离到上面</p> </blockquote> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">K</span> ↑</span></span><br><span class="line">Windows：ctrl + K ↑</span><br></pre></td></tr></table></figure> <blockquote> <p>分离到下面</p> </blockquote> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">K</span> ↓</span></span><br><span class="line">Windows：ctrl + K ↓</span><br></pre></td></tr></table></figure> <blockquote> <p>分离到左面</p> </blockquote> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">K</span> ←</span></span><br><span class="line">Windows：ctrl + K ←</span><br></pre></td></tr></table></figure> <blockquote> <p>分离到右面</p> </blockquote> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">K</span> →</span></span><br><span class="line">Windows：ctrl + K →</span><br></pre></td></tr></table></figure> <blockquote> <p>注意上面这些快捷键的用法，是先按一下 command + K 或者 ctrl + K ，然后松开按键，再按一下上，下，左，右这些箭头按键。</p> </blockquote> <h2 id="查找文件">查找文件</h2><p>项目里的文件多了，想找到对应的文件，用鼠标点出这个文件很费事，可以用搜索找到文件。</p> <p>在已经打开的文件里找到你想要的文件：</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">B</span></span></span><br><span class="line">Windows：ctrl + B</span><br></pre></td></tr></table></figure> <p><img src="http://zanjs.b0.upaiyun.com/image/4/1b/d643f0a52d1e1457321f8b6b61433.png" alt=""></p> <p>在整个项目里找到你需要的文件：</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">P</span></span></span><br><span class="line">Windows：ctrl + P</span><br></pre></td></tr></table></figure> <p>查找文件里的内容</p> <p>你可以搜索包含特定内容的文件，比如在当前打开的文件里搜索，或者也可以在整个项目里搜索，<br>找到以后，可以把搜索的内容替换成新的内容。</p> <p>在当前打开的文件中搜索</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mac</span>    ：command + <span class="literal">F</span></span><br><span class="line">Windows：ctrl + <span class="literal">F</span></span><br></pre></td></tr></table></figure> <p>我想知道有没有查找下一处或者上一处的快捷键，<br>打开命令面板（Mac：command + shift + P，Windows：ctrl + shift + P），搜索 find ，仔细阅读一下，<br>你会看到 Find Next ， Find Previous 还有跟它们对应的快捷键。</p> <p>查找下一个地方</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">G</span></span></span><br><span class="line">Windows：F3</span><br></pre></td></tr></table></figure> <p>查找上一个地方</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="built_in">shift</span> + <span class="built_in">command</span> + G</span><br><span class="line">Windows：<span class="built_in">shift</span> + F3</span><br></pre></td></tr></table></figure> <p>在整个项目中搜索</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="built_in">shift</span> + <span class="built_in">command</span> + F</span><br><span class="line">Windows：<span class="built_in">shift</span> + ctrl + F</span><br></pre></td></tr></table></figure> <p>下面，是我搜索了项目中的 header ，回车以后，会显示出找到的结果，<br>这个结果显示了包含搜索的内容的文件，还有出现这个内容的位置，点一下，会打开出现这个搜索内容的文件，并且会定位到对应的位置上。</p> <p><img src="http://zanjs.b0.upaiyun.com/image/6/94/e6a866d83ab1e28d8bf6b0cb81b9e.png" alt="整个项目"></p> <h2 id="读后感">读后感</h2><p>小伙伴们 辛苦了， 能读到这里，一定吐了吧 ，<code>O(∩_∩)O哈哈~</code> , 写的我也快吐了, 排版的不是很好 见谅一下吧。</p> <p>下面欣赏一下美图吧！</p> <p><img src="http://zanjs.b0.upaiyun.com/image/5/09/af43f4834b28c25f60bfcfb3ec523.jpeg" alt="美图"></p>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Atom">Atom</h2><p>一款编辑器入门还是很简单的，学会怎么样创建，打开，编辑，保存文件就行。<br>剩下的就是慢慢熟悉，Atom 会不断带给你惊喜，如果你想简化或者加快平时工作中的某些任务或者动作，你就可以去搜索一下，Atom 要么本身就为你提供你需]]>
    </summary>
    
      <category term="atom" scheme="http://zanjs.com/tags/atom/"/>
    
      <category term="前端开发编辑器" scheme="http://zanjs.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="开发工具" scheme="http://zanjs.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发工具" scheme="http://zanjs.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[欢迎使用马克飞象]]></title>
    <link href="http://zanjs.com/2015/10/25/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/"/>
    <id>http://zanjs.com/2015/10/25/欢迎使用马克飞象/</id>
    <published>2015-10-25T08:24:50.000Z</published>
    <updated>2015-11-20T13:27:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="欢迎使用马克飞象">欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p> <p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p> <ul> <li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li> <li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="external">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="external">离线Chrome App</a>，支持移动端 Web；</li> <li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li> </ul> <hr> <p>[TOC]</p> <h2 id="Markdown简介">Markdown简介</h2><blockquote> <p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a></p> </blockquote> <p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="external">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。</p> <h3 id="代码块">代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span><br><span class="line"><span class="prompt">... </span>prompt'''</span></span><br></pre></td></tr></table></figure> <h3 id="LaTeX_公式">LaTeX 公式</h3> <p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p> <p>$$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p> <h3 id="表格">表格</h3><table> <thead> <tr> <th style="text-align:left">Item</th> <th style="text-align:right">Value</th> <th style="text-align:center">Qty</th> </tr> </thead> <tbody> <tr> <td style="text-align:left">Computer</td> <td style="text-align:right">1600 USD</td> <td style="text-align:center">5</td> </tr> <tr> <td style="text-align:left">Phone</td> <td style="text-align:right">12 USD</td> <td style="text-align:center">12</td> </tr> <tr> <td style="text-align:left">Pipe</td> <td style="text-align:right">1 USD</td> <td style="text-align:center">234</td> </tr> </tbody> </table> <h3 id="流程图">流程图</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st=&#62;start: Start&#10;e=&#62;end&#10;op=&#62;operation: My Operation&#10;cond=&#62;condition: Yes or No?&#10;&#10;st-&#62;op-&#62;cond&#10;cond(yes)-&#62;e&#10;cond(no)-&#62;op</span><br></pre></td></tr></table></figure> <p>以及时序图:</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alice-&#62;Bob: Hello Bob, how are you?&#10;Note right of Bob: Bob thinks&#10;Bob--&#62;Alice: I am good thanks!</span><br></pre></td></tr></table></figure> <blockquote> <p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">语法</a>。</p> </blockquote> <h3 id="复选框">复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p> <ul> <li>[x] 已完成事项</li> <li>[ ] 待办事项1</li> <li>[ ] 待办事项2</li> </ul> <blockquote> <p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p> </blockquote> <h2 id="印象笔记相关">印象笔记相关</h2><h3 id="笔记本和标签">笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p> <h3 id="笔记标题">笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p> <h3 id="快捷编辑">快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p> <blockquote> <p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p> </blockquote> <h3 id="数据同步">数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p> <blockquote> <p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p> </blockquote> <h3 id="离线存储">离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p> <blockquote> <p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p> </blockquote> <h2 id="编辑器相关">编辑器相关</h2><h3 id="设置">设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p> <h3 id="快捷键">快捷键</h3><p>帮助 <code>Ctrl + /</code><br>同步文档 <code>Ctrl + S</code><br>创建文档 <code>Ctrl + Alt + N</code><br>最大化编辑器 <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理 <code>Ctrl + O</code><br>系统菜单 <code>Ctrl + M</code></p> <p>加粗 <code>Ctrl + B</code><br>插入图片 <code>Ctrl + G</code><br>插入链接 <code>Ctrl + L</code><br>提升标题 <code>Ctrl + H</code></p> <h2 id="关于收费">关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p> <h2 id="反馈与建议">反馈与建议</h2><ul> <li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="external">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="external">@GGock</a></li> <li>邮箱：<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#104;&#x75;&#x73;&#x74;&#103;&#111;&#99;&#107;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#104;&#x75;&#x73;&#x74;&#103;&#111;&#99;&#107;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></li> </ul> <hr> <p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p> <p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="external">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="external">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="欢迎使用马克飞象">欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p> <p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象]]>
    </summary>
    
      <category term="help" scheme="http://zanjs.com/tags/help/"/>
    
      <category term="writing" scheme="http://zanjs.com/tags/writing/"/>
    
      <category term="help" scheme="http://zanjs.com/categories/help/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[writing 写作帮助]]></title>
    <link href="http://zanjs.com/2015/10/25/writing/"/>
    <id>http://zanjs.com/2015/10/25/writing/</id>
    <published>2015-10-25T07:57:45.000Z</published>
    <updated>2015-11-20T13:27:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="写作">写作</h1><p>接下来，我们要在网站中建立第一篇文章，您可以直接从现有的示例文章「Hello World」改写，但我们更建议您学习 new 指令。</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">[layout]</span> &lt;title&gt;</span><br></pre></td></tr></table></figure> <p>您可以在命令中指定文章的布局<code>（layout）</code>，默认为 <code>post</code>，<br>可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p> <h2 id="布局（Layout）">布局（Layout）</h2><p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，<br>而您自定义的其他布局和 post 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>  <table> <thead> <tr> <th>布局</th> <th style="text-align:center">路径</th> </tr> </thead> <tbody> <tr> <td>post</td> <td style="text-align:center">source/_posts</td> </tr> <tr> <td>page</td> <td style="text-align:center">source</td> </tr> <tr> <td>draft</td> <td style="text-align:center">source/_drafts</td> </tr> </tbody> </table> <h2 id="文件名称">文件名称</h2><p>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，<br>举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p> <h2 id="草稿">草稿</h2><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，<br>您可通过 publish 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 new 十分类似，<br>您也可在命令中指定 layout 来指定布局。</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish <span class="string">[layout]</span> &lt;title&gt;</span><br></pre></td></tr></table></figure> <p>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p> <h2 id="模版（Scaffold">模版（Scaffold</h2><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p> <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> photo <span class="string">"My Gallery"</span></span><br></pre></td></tr></table></figure> <p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="写作">写作</h1><p>接下来，我们要在网站中建立第一篇文章，您可以直接从现有的示例文章「Hello World」改写，但我们更建议您学习 new 指令。</p> <figure class="highlight accesslog"><table><tr><]]>
    </summary>
    
      <category term="help" scheme="http://zanjs.com/tags/help/"/>
    
      <category term="writing" scheme="http://zanjs.com/tags/writing/"/>
    
      <category term="help" scheme="http://zanjs.com/categories/help/"/>
    
  </entry>
  
</feed>
